schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

scalar _name

"""
Boolean expression to compare columns of type "_name". All fields are combined with logical 'AND'.
"""
input _name_comparison_exp {
  _eq: _name
  _gt: _name
  _gte: _name
  _in: [_name!]
  _is_null: Boolean
  _lt: _name
  _lte: _name
  _neq: _name
  _nin: [_name!]
}

type AnswerResult {
  result: String!
}

"""
columns and relationships of "apps"
"""
type apps {
  created_at: timestamptz!

  """
  An object relationship
  """
  developer: developers!
  developer_id: Int!
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb!
  object_id: Int!
  slug: String!
}

"""
aggregated selection of "apps"
"""
type apps_aggregate {
  aggregate: apps_aggregate_fields
  nodes: [apps!]!
}

"""
aggregate fields of "apps"
"""
type apps_aggregate_fields {
  avg: apps_avg_fields
  count(columns: [apps_select_column!], distinct: Boolean): Int!
  max: apps_max_fields
  min: apps_min_fields
  stddev: apps_stddev_fields
  stddev_pop: apps_stddev_pop_fields
  stddev_samp: apps_stddev_samp_fields
  sum: apps_sum_fields
  var_pop: apps_var_pop_fields
  var_samp: apps_var_samp_fields
  variance: apps_variance_fields
}

"""
order by aggregate values of table "apps"
"""
input apps_aggregate_order_by {
  avg: apps_avg_order_by
  count: order_by
  max: apps_max_order_by
  min: apps_min_order_by
  stddev: apps_stddev_order_by
  stddev_pop: apps_stddev_pop_order_by
  stddev_samp: apps_stddev_samp_order_by
  sum: apps_sum_order_by
  var_pop: apps_var_pop_order_by
  var_samp: apps_var_samp_order_by
  variance: apps_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input apps_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "apps"
"""
input apps_arr_rel_insert_input {
  data: [apps_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: apps_on_conflict
}

"""
aggregate avg on columns
"""
type apps_avg_fields {
  developer_id: Float
  object_id: Float
}

"""
order by avg() on columns of table "apps"
"""
input apps_avg_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
Boolean expression to filter rows from the table "apps". All fields are combined with a logical 'AND'.
"""
input apps_bool_exp {
  _and: [apps_bool_exp!]
  _not: apps_bool_exp
  _or: [apps_bool_exp!]
  created_at: timestamptz_comparison_exp
  developer: developers_bool_exp
  developer_id: Int_comparison_exp
  metadata: jsonb_comparison_exp
  object_id: Int_comparison_exp
  slug: String_comparison_exp
}

"""
unique or primary key constraints on table "apps"
"""
enum apps_constraint {
  """
  unique or primary key constraint
  """
  apps_object_id_key

  """
  unique or primary key constraint
  """
  apps_slug_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input apps_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input apps_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input apps_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "apps"
"""
input apps_inc_input {
  developer_id: Int
  object_id: Int
}

"""
input type for inserting data into table "apps"
"""
input apps_insert_input {
  created_at: timestamptz
  developer: developers_obj_rel_insert_input
  developer_id: Int
  metadata: jsonb
  object_id: Int
  slug: String
}

"""
aggregate max on columns
"""
type apps_max_fields {
  created_at: timestamptz
  developer_id: Int
  object_id: Int
  slug: String
}

"""
order by max() on columns of table "apps"
"""
input apps_max_order_by {
  created_at: order_by
  developer_id: order_by
  object_id: order_by
  slug: order_by
}

"""
aggregate min on columns
"""
type apps_min_fields {
  created_at: timestamptz
  developer_id: Int
  object_id: Int
  slug: String
}

"""
order by min() on columns of table "apps"
"""
input apps_min_order_by {
  created_at: order_by
  developer_id: order_by
  object_id: order_by
  slug: order_by
}

"""
response of any mutation on the table "apps"
"""
type apps_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [apps!]!
}

"""
on conflict condition type for table "apps"
"""
input apps_on_conflict {
  constraint: apps_constraint!
  update_columns: [apps_update_column!]! = []
  where: apps_bool_exp
}

"""
Ordering options when selecting data from "apps".
"""
input apps_order_by {
  created_at: order_by
  developer: developers_order_by
  developer_id: order_by
  metadata: order_by
  object_id: order_by
  slug: order_by
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input apps_prepend_input {
  metadata: jsonb
}

"""
select columns of table "apps"
"""
enum apps_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  developer_id

  """
  column name
  """
  metadata

  """
  column name
  """
  object_id

  """
  column name
  """
  slug
}

"""
input type for updating data in table "apps"
"""
input apps_set_input {
  created_at: timestamptz
  developer_id: Int
  metadata: jsonb
  object_id: Int
  slug: String
}

"""
aggregate stddev on columns
"""
type apps_stddev_fields {
  developer_id: Float
  object_id: Float
}

"""
order by stddev() on columns of table "apps"
"""
input apps_stddev_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type apps_stddev_pop_fields {
  developer_id: Float
  object_id: Float
}

"""
order by stddev_pop() on columns of table "apps"
"""
input apps_stddev_pop_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type apps_stddev_samp_fields {
  developer_id: Float
  object_id: Float
}

"""
order by stddev_samp() on columns of table "apps"
"""
input apps_stddev_samp_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
aggregate sum on columns
"""
type apps_sum_fields {
  developer_id: Int
  object_id: Int
}

"""
order by sum() on columns of table "apps"
"""
input apps_sum_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
update columns of table "apps"
"""
enum apps_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  developer_id

  """
  column name
  """
  metadata

  """
  column name
  """
  object_id

  """
  column name
  """
  slug
}

"""
aggregate var_pop on columns
"""
type apps_var_pop_fields {
  developer_id: Float
  object_id: Float
}

"""
order by var_pop() on columns of table "apps"
"""
input apps_var_pop_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
aggregate var_samp on columns
"""
type apps_var_samp_fields {
  developer_id: Float
  object_id: Float
}

"""
order by var_samp() on columns of table "apps"
"""
input apps_var_samp_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
aggregate variance on columns
"""
type apps_variance_fields {
  developer_id: Float
  object_id: Float
}

"""
order by variance() on columns of table "apps"
"""
input apps_variance_order_by {
  developer_id: order_by
  object_id: order_by
}

"""
The `Base64` scalar type represents a base64-encoded String.
"""
scalar Base64

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type ChitchatResult {
  result: String!
}

"""
columns and relationships of "developers"
"""
type developers {
  active: Boolean!
  api_key: String!

  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): [apps!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): apps_aggregate!
  created_at: timestamptz!
  email: String!
  github_handle: String
  metadata(
    """
    JSON select path
    """
    path: String
  ): jsonb!
  name: String!
  object_id: Int!
  onboarded: Boolean!

  """
  An array relationship
  """
  tokens(
    """
    distinct select on columns
    """
    distinct_on: [tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tokens_order_by!]

    """
    filter the rows returned
    """
    where: tokens_bool_exp
  ): [tokens!]!

  """
  An aggregate relationship
  """
  tokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tokens_order_by!]

    """
    filter the rows returned
    """
    where: tokens_bool_exp
  ): tokens_aggregate!
  uid: String!

  """
  An array relationship
  """
  usages(
    """
    distinct select on columns
    """
    distinct_on: [usage_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [usage_order_by!]

    """
    filter the rows returned
    """
    where: usage_bool_exp
  ): [usage!]!

  """
  An aggregate relationship
  """
  usages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [usage_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [usage_order_by!]

    """
    filter the rows returned
    """
    where: usage_bool_exp
  ): usage_aggregate!
}

"""
aggregated selection of "developers"
"""
type developers_aggregate {
  aggregate: developers_aggregate_fields
  nodes: [developers!]!
}

"""
aggregate fields of "developers"
"""
type developers_aggregate_fields {
  avg: developers_avg_fields
  count(columns: [developers_select_column!], distinct: Boolean): Int!
  max: developers_max_fields
  min: developers_min_fields
  stddev: developers_stddev_fields
  stddev_pop: developers_stddev_pop_fields
  stddev_samp: developers_stddev_samp_fields
  sum: developers_sum_fields
  var_pop: developers_var_pop_fields
  var_samp: developers_var_samp_fields
  variance: developers_variance_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input developers_append_input {
  metadata: jsonb
}

"""
aggregate avg on columns
"""
type developers_avg_fields {
  object_id: Float
}

"""
Boolean expression to filter rows from the table "developers". All fields are combined with a logical 'AND'.
"""
input developers_bool_exp {
  _and: [developers_bool_exp!]
  _not: developers_bool_exp
  _or: [developers_bool_exp!]
  active: Boolean_comparison_exp
  api_key: String_comparison_exp
  apps: apps_bool_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  github_handle: String_comparison_exp
  metadata: jsonb_comparison_exp
  name: String_comparison_exp
  object_id: Int_comparison_exp
  onboarded: Boolean_comparison_exp
  tokens: tokens_bool_exp
  uid: String_comparison_exp
  usages: usage_bool_exp
}

"""
unique or primary key constraints on table "developers"
"""
enum developers_constraint {
  """
  unique or primary key constraint
  """
  developers_api_key_key

  """
  unique or primary key constraint
  """
  developers_email_key

  """
  unique or primary key constraint
  """
  developers_github_handle_key

  """
  unique or primary key constraint
  """
  developers_object_id_key

  """
  unique or primary key constraint
  """
  developers_uid_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input developers_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input developers_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input developers_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "developers"
"""
input developers_inc_input {
  object_id: Int
}

"""
input type for inserting data into table "developers"
"""
input developers_insert_input {
  active: Boolean
  api_key: String
  apps: apps_arr_rel_insert_input
  created_at: timestamptz
  email: String
  github_handle: String
  metadata: jsonb
  name: String
  object_id: Int
  onboarded: Boolean
  tokens: tokens_arr_rel_insert_input
  uid: String
  usages: usage_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type developers_max_fields {
  api_key: String
  created_at: timestamptz
  email: String
  github_handle: String
  name: String
  object_id: Int
  uid: String
}

"""
aggregate min on columns
"""
type developers_min_fields {
  api_key: String
  created_at: timestamptz
  email: String
  github_handle: String
  name: String
  object_id: Int
  uid: String
}

"""
response of any mutation on the table "developers"
"""
type developers_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [developers!]!
}

"""
input type for inserting object relation for remote table "developers"
"""
input developers_obj_rel_insert_input {
  data: developers_insert_input!

  """
  on conflict condition
  """
  on_conflict: developers_on_conflict
}

"""
on conflict condition type for table "developers"
"""
input developers_on_conflict {
  constraint: developers_constraint!
  update_columns: [developers_update_column!]! = []
  where: developers_bool_exp
}

"""
Ordering options when selecting data from "developers".
"""
input developers_order_by {
  active: order_by
  api_key: order_by
  apps_aggregate: apps_aggregate_order_by
  created_at: order_by
  email: order_by
  github_handle: order_by
  metadata: order_by
  name: order_by
  object_id: order_by
  onboarded: order_by
  tokens_aggregate: tokens_aggregate_order_by
  uid: order_by
  usages_aggregate: usage_aggregate_order_by
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input developers_prepend_input {
  metadata: jsonb
}

"""
select columns of table "developers"
"""
enum developers_select_column {
  """
  column name
  """
  active

  """
  column name
  """
  api_key

  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  github_handle

  """
  column name
  """
  metadata

  """
  column name
  """
  name

  """
  column name
  """
  object_id

  """
  column name
  """
  onboarded

  """
  column name
  """
  uid
}

"""
input type for updating data in table "developers"
"""
input developers_set_input {
  active: Boolean
  api_key: String
  created_at: timestamptz
  email: String
  github_handle: String
  metadata: jsonb
  name: String
  object_id: Int
  onboarded: Boolean
  uid: String
}

"""
aggregate stddev on columns
"""
type developers_stddev_fields {
  object_id: Float
}

"""
aggregate stddev_pop on columns
"""
type developers_stddev_pop_fields {
  object_id: Float
}

"""
aggregate stddev_samp on columns
"""
type developers_stddev_samp_fields {
  object_id: Float
}

"""
aggregate sum on columns
"""
type developers_sum_fields {
  object_id: Int
}

"""
update columns of table "developers"
"""
enum developers_update_column {
  """
  column name
  """
  active

  """
  column name
  """
  api_key

  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  github_handle

  """
  column name
  """
  metadata

  """
  column name
  """
  name

  """
  column name
  """
  object_id

  """
  column name
  """
  onboarded

  """
  column name
  """
  uid
}

"""
aggregate var_pop on columns
"""
type developers_var_pop_fields {
  object_id: Float
}

"""
aggregate var_samp on columns
"""
type developers_var_samp_fields {
  object_id: Float
}

"""
aggregate variance on columns
"""
type developers_variance_fields {
  object_id: Float
}

type DialogactResult {
  result: String!
}

type DialogAlternative {
  alternative: String!
  score: Float!
}

"""
columns and relationships of "events"
"""
type events {
  action: String
  changed_fields(
    """
    JSON select path
    """
    path: String
  ): jsonb
  developer_id: String
  table: String
  timestamp: timestamptz
}

"""
aggregated selection of "events"
"""
type events_aggregate {
  aggregate: events_aggregate_fields
  nodes: [events!]!
}

"""
aggregate fields of "events"
"""
type events_aggregate_fields {
  count(columns: [events_select_column!], distinct: Boolean): Int!
  max: events_max_fields
  min: events_min_fields
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input events_append_input {
  changed_fields: jsonb
}

"""
Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'.
"""
input events_bool_exp {
  _and: [events_bool_exp!]
  _not: events_bool_exp
  _or: [events_bool_exp!]
  action: String_comparison_exp
  changed_fields: jsonb_comparison_exp
  developer_id: String_comparison_exp
  table: String_comparison_exp
  timestamp: timestamptz_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input events_delete_at_path_input {
  changed_fields: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input events_delete_elem_input {
  changed_fields: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input events_delete_key_input {
  changed_fields: String
}

"""
input type for inserting data into table "events"
"""
input events_insert_input {
  action: String
  changed_fields: jsonb
  developer_id: String
  table: String
  timestamp: timestamptz
}

"""
aggregate max on columns
"""
type events_max_fields {
  action: String
  developer_id: String
  table: String
  timestamp: timestamptz
}

"""
aggregate min on columns
"""
type events_min_fields {
  action: String
  developer_id: String
  table: String
  timestamp: timestamptz
}

"""
response of any mutation on the table "events"
"""
type events_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [events!]!
}

"""
Ordering options when selecting data from "events".
"""
input events_order_by {
  action: order_by
  changed_fields: order_by
  developer_id: order_by
  table: order_by
  timestamp: order_by
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input events_prepend_input {
  changed_fields: jsonb
}

"""
select columns of table "events"
"""
enum events_select_column {
  """
  column name
  """
  action

  """
  column name
  """
  changed_fields

  """
  column name
  """
  developer_id

  """
  column name
  """
  table

  """
  column name
  """
  timestamp
}

"""
input type for updating data in table "events"
"""
input events_set_input {
  action: String
  changed_fields: jsonb
  developer_id: String
  table: String
  timestamp: timestamptz
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar interval

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input interval_comparison_exp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _is_null: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb

  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """
  does the string exist as a top-level key in the column
  """
  _has_key: String

  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]

  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "apps"
  """
  delete_apps(
    """
    filter the rows which have to be deleted
    """
    where: apps_bool_exp!
  ): apps_mutation_response

  """
  delete data from the table: "developers"
  """
  delete_developers(
    """
    filter the rows which have to be deleted
    """
    where: developers_bool_exp!
  ): developers_mutation_response

  """
  delete data from the table: "events"
  """
  delete_events(
    """
    filter the rows which have to be deleted
    """
    where: events_bool_exp!
  ): events_mutation_response

  """
  delete data from the table: "tokens"
  """
  delete_tokens(
    """
    filter the rows which have to be deleted
    """
    where: tokens_bool_exp!
  ): tokens_mutation_response

  """
  delete single row from the table: "tokens"
  """
  delete_tokens_by_pk(developer_id: Int!, slug: String!): tokens

  """
  delete data from the table: "usage"
  """
  delete_usage(
    """
    filter the rows which have to be deleted
    """
    where: usage_bool_exp!
  ): usage_mutation_response

  """
  insert data into the table: "apps"
  """
  insert_apps(
    """
    the rows to be inserted
    """
    objects: [apps_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: apps_on_conflict
  ): apps_mutation_response

  """
  insert a single row into the table: "apps"
  """
  insert_apps_one(
    """
    the row to be inserted
    """
    object: apps_insert_input!

    """
    on conflict condition
    """
    on_conflict: apps_on_conflict
  ): apps

  """
  insert data into the table: "developers"
  """
  insert_developers(
    """
    the rows to be inserted
    """
    objects: [developers_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: developers_on_conflict
  ): developers_mutation_response

  """
  insert a single row into the table: "developers"
  """
  insert_developers_one(
    """
    the row to be inserted
    """
    object: developers_insert_input!

    """
    on conflict condition
    """
    on_conflict: developers_on_conflict
  ): developers

  """
  insert data into the table: "events"
  """
  insert_events(
    """
    the rows to be inserted
    """
    objects: [events_insert_input!]!
  ): events_mutation_response

  """
  insert a single row into the table: "events"
  """
  insert_events_one(
    """
    the row to be inserted
    """
    object: events_insert_input!
  ): events

  """
  insert data into the table: "tokens"
  """
  insert_tokens(
    """
    the rows to be inserted
    """
    objects: [tokens_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tokens_on_conflict
  ): tokens_mutation_response

  """
  insert a single row into the table: "tokens"
  """
  insert_tokens_one(
    """
    the row to be inserted
    """
    object: tokens_insert_input!

    """
    on conflict condition
    """
    on_conflict: tokens_on_conflict
  ): tokens

  """
  insert data into the table: "usage"
  """
  insert_usage(
    """
    the rows to be inserted
    """
    objects: [usage_insert_input!]!
  ): usage_mutation_response

  """
  insert a single row into the table: "usage"
  """
  insert_usage_one(
    """
    the row to be inserted
    """
    object: usage_insert_input!
  ): usage

  """
  update data of the table: "apps"
  """
  update_apps(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: apps_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: apps_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: apps_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: apps_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: apps_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: apps_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: apps_set_input

    """
    filter the rows which have to be updated
    """
    where: apps_bool_exp!
  ): apps_mutation_response

  """
  update data of the table: "developers"
  """
  update_developers(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: developers_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: developers_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: developers_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: developers_delete_key_input

    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: developers_inc_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: developers_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: developers_set_input

    """
    filter the rows which have to be updated
    """
    where: developers_bool_exp!
  ): developers_mutation_response

  """
  update data of the table: "events"
  """
  update_events(
    """
    append existing jsonb value of filtered columns with new jsonb value
    """
    _append: events_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: events_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: events_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: events_delete_key_input

    """
    prepend existing jsonb value of filtered columns with new jsonb value
    """
    _prepend: events_prepend_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: events_set_input

    """
    filter the rows which have to be updated
    """
    where: events_bool_exp!
  ): events_mutation_response

  """
  update data of the table: "tokens"
  """
  update_tokens(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: tokens_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: tokens_set_input

    """
    filter the rows which have to be updated
    """
    where: tokens_bool_exp!
  ): tokens_mutation_response

  """
  update single row of the table: "tokens"
  """
  update_tokens_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: tokens_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: tokens_set_input
    pk_columns: tokens_pk_columns_input!
  ): tokens

  """
  update data of the table: "usage"
  """
  update_usage(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: usage_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: usage_set_input

    """
    filter the rows which have to be updated
    """
    where: usage_bool_exp!
  ): usage_mutation_response
}

scalar name

"""
Boolean expression to compare columns of type "name". All fields are combined with logical 'AND'.
"""
input name_comparison_exp {
  _eq: name
  _gt: name
  _gte: name
  _in: [name!]
  _is_null: Boolean
  _lt: name
  _lte: name
  _neq: name
  _nin: [name!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type PairSimilarity {
  """
  Similarity sentences pair
  """
  candidate: String

  """
  Similarity sentences pair
  """
  input: String

  """
  Similarity score
  """
  score: Float
}

type ParaphraseResult {
  result: [String!]!
}

type query_root {
  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): [apps!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): apps_aggregate!
  callAnswer(
    choices: [String!]! = []
    context: String!
    input: String!
    minLength: Int! = 1
  ): AnswerResult!
  callChitchat(history: [Turn!]! = [], input: String!): ChitchatResult!
  callDialogact(input: String!): DialogactResult!
  callParaphrase(input: String!): ParaphraseResult!
  callRelations(input: String!, relation: Relation!): RelationsResult!
  callSensibility(history: [Turn!]!, input: [String!]!): SensibilityResult!
  callSentiment(input: String!): SentimentResult!

  """
  Measure sentences similarity
  """
  callSimilarity(candidates: [String!]!, input: String!): SimilarityResult
  callSpeak(input: String!): SpeakResult!

  """
  Classify topics
  """
  callTopics(
    """
    Allow multiple topics to be applicable
    """
    allow_multiple: Boolean!
    input: String!
    topics: [String!]!
  ): TopicsResult!

  """
  Convert speech to text
  """
  callTranscribe(
    """
    Input string of bytes
    """
    input: Base64!
  ): TranscribeResult!

  """
  fetch data from the table: "developers"
  """
  developers(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): [developers!]!

  """
  fetch aggregated fields from the table: "developers"
  """
  developers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): developers_aggregate!

  """
  fetch data from the table: "events"
  """
  events(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): events_aggregate!

  """
  execute function "me" which returns "developers"
  """
  me(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): [developers!]!

  """
  execute function "me" and query aggregates on result of table type "developers"
  """
  me_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): developers_aggregate!

  """
  fetch data from the table: "timescaledb_information.chunks"
  """
  timescaledb_information_chunks(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_chunks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_chunks_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_chunks_bool_exp
  ): [timescaledb_information_chunks!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.chunks"
  """
  timescaledb_information_chunks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_chunks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_chunks_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_chunks_bool_exp
  ): timescaledb_information_chunks_aggregate!

  """
  fetch data from the table: "timescaledb_information.compression_settings"
  """
  timescaledb_information_compression_settings(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_compression_settings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_compression_settings_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_compression_settings_bool_exp
  ): [timescaledb_information_compression_settings!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.compression_settings"
  """
  timescaledb_information_compression_settings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_compression_settings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_compression_settings_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_compression_settings_bool_exp
  ): timescaledb_information_compression_settings_aggregate!

  """
  fetch data from the table: "timescaledb_information.continuous_aggregates"
  """
  timescaledb_information_continuous_aggregates(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_continuous_aggregates_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_continuous_aggregates_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_continuous_aggregates_bool_exp
  ): [timescaledb_information_continuous_aggregates!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.continuous_aggregates"
  """
  timescaledb_information_continuous_aggregates_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_continuous_aggregates_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_continuous_aggregates_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_continuous_aggregates_bool_exp
  ): timescaledb_information_continuous_aggregates_aggregate!

  """
  fetch data from the table: "timescaledb_information.hypertables"
  """
  timescaledb_information_hypertables(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_hypertables_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_hypertables_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_hypertables_bool_exp
  ): [timescaledb_information_hypertables!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.hypertables"
  """
  timescaledb_information_hypertables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_hypertables_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_hypertables_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_hypertables_bool_exp
  ): timescaledb_information_hypertables_aggregate!

  """
  fetch data from the table: "timescaledb_information.job_stats"
  """
  timescaledb_information_job_stats(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_job_stats_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_job_stats_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_job_stats_bool_exp
  ): [timescaledb_information_job_stats!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.job_stats"
  """
  timescaledb_information_job_stats_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_job_stats_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_job_stats_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_job_stats_bool_exp
  ): timescaledb_information_job_stats_aggregate!

  """
  fetch data from the table: "timescaledb_information.jobs"
  """
  timescaledb_information_jobs(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_jobs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_jobs_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_jobs_bool_exp
  ): [timescaledb_information_jobs!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.jobs"
  """
  timescaledb_information_jobs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_jobs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_jobs_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_jobs_bool_exp
  ): timescaledb_information_jobs_aggregate!

  """
  An array relationship
  """
  tokens(
    """
    distinct select on columns
    """
    distinct_on: [tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tokens_order_by!]

    """
    filter the rows returned
    """
    where: tokens_bool_exp
  ): [tokens!]!

  """
  An aggregate relationship
  """
  tokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tokens_order_by!]

    """
    filter the rows returned
    """
    where: tokens_bool_exp
  ): tokens_aggregate!

  """
  fetch data from the table: "tokens" using primary key columns
  """
  tokens_by_pk(developer_id: Int!, slug: String!): tokens

  """
  fetch data from the table: "usage"
  """
  usage(
    """
    distinct select on columns
    """
    distinct_on: [usage_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [usage_order_by!]

    """
    filter the rows returned
    """
    where: usage_bool_exp
  ): [usage!]!

  """
  fetch aggregated fields from the table: "usage"
  """
  usage_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [usage_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [usage_order_by!]

    """
    filter the rows returned
    """
    where: usage_bool_exp
  ): usage_aggregate!
}

scalar regtype

"""
Boolean expression to compare columns of type "regtype". All fields are combined with logical 'AND'.
"""
input regtype_comparison_exp {
  _eq: regtype
  _gt: regtype
  _gte: regtype
  _in: [regtype!]
  _is_null: Boolean
  _lt: regtype
  _lte: regtype
  _neq: regtype
  _nin: [regtype!]
}

enum Relation {
  AtLocation
  CapableOf
  Causes
  CausesDesire
  CreatedBy
  DefinedAs
  DesireOf
  Desires
  HasA
  HasFirstSubevent
  HasLastSubevent
  HasPainCharacter
  HasPainIntensity
  HasPrerequisite
  HasProperty
  HasSubevent
  InheritsFrom
  InstanceOf
  IsA
  LocatedNear
  LocationOfAction
  MadeOf
  MotivatedByGoal
  NotCapableOf
  NotDesires
  NotHasA
  NotHasProperty
  NotIsA
  NotMadeOf
  PartOf
  ReceivesAction
  RelatedTo
  SymbolOf
  UsedFor
}

type RelationsResult {
  result: [String!]!
}

type SensibilityResult {
  result: [DialogAlternative!]!
}

type SentimentAnalysis {
  label: String!
  score: Float!
}

type SentimentResult {
  result: [SentimentAnalysis!]!
}

"""
Sentence similarity score
"""
type SimilarityResult {
  result: [PairSimilarity!]!
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

type SpeakResult {
  result: String!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type subscription_root {
  """
  An array relationship
  """
  apps(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): [apps!]!

  """
  An aggregate relationship
  """
  apps_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [apps_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [apps_order_by!]

    """
    filter the rows returned
    """
    where: apps_bool_exp
  ): apps_aggregate!

  """
  fetch data from the table: "developers"
  """
  developers(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): [developers!]!

  """
  fetch aggregated fields from the table: "developers"
  """
  developers_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): developers_aggregate!

  """
  fetch data from the table: "events"
  """
  events(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): [events!]!

  """
  fetch aggregated fields from the table: "events"
  """
  events_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [events_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [events_order_by!]

    """
    filter the rows returned
    """
    where: events_bool_exp
  ): events_aggregate!

  """
  execute function "me" which returns "developers"
  """
  me(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): [developers!]!

  """
  execute function "me" and query aggregates on result of table type "developers"
  """
  me_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [developers_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [developers_order_by!]

    """
    filter the rows returned
    """
    where: developers_bool_exp
  ): developers_aggregate!

  """
  fetch data from the table: "timescaledb_information.chunks"
  """
  timescaledb_information_chunks(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_chunks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_chunks_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_chunks_bool_exp
  ): [timescaledb_information_chunks!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.chunks"
  """
  timescaledb_information_chunks_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_chunks_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_chunks_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_chunks_bool_exp
  ): timescaledb_information_chunks_aggregate!

  """
  fetch data from the table: "timescaledb_information.compression_settings"
  """
  timescaledb_information_compression_settings(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_compression_settings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_compression_settings_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_compression_settings_bool_exp
  ): [timescaledb_information_compression_settings!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.compression_settings"
  """
  timescaledb_information_compression_settings_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_compression_settings_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_compression_settings_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_compression_settings_bool_exp
  ): timescaledb_information_compression_settings_aggregate!

  """
  fetch data from the table: "timescaledb_information.continuous_aggregates"
  """
  timescaledb_information_continuous_aggregates(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_continuous_aggregates_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_continuous_aggregates_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_continuous_aggregates_bool_exp
  ): [timescaledb_information_continuous_aggregates!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.continuous_aggregates"
  """
  timescaledb_information_continuous_aggregates_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_continuous_aggregates_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_continuous_aggregates_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_continuous_aggregates_bool_exp
  ): timescaledb_information_continuous_aggregates_aggregate!

  """
  fetch data from the table: "timescaledb_information.hypertables"
  """
  timescaledb_information_hypertables(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_hypertables_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_hypertables_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_hypertables_bool_exp
  ): [timescaledb_information_hypertables!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.hypertables"
  """
  timescaledb_information_hypertables_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_hypertables_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_hypertables_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_hypertables_bool_exp
  ): timescaledb_information_hypertables_aggregate!

  """
  fetch data from the table: "timescaledb_information.job_stats"
  """
  timescaledb_information_job_stats(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_job_stats_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_job_stats_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_job_stats_bool_exp
  ): [timescaledb_information_job_stats!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.job_stats"
  """
  timescaledb_information_job_stats_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_job_stats_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_job_stats_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_job_stats_bool_exp
  ): timescaledb_information_job_stats_aggregate!

  """
  fetch data from the table: "timescaledb_information.jobs"
  """
  timescaledb_information_jobs(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_jobs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_jobs_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_jobs_bool_exp
  ): [timescaledb_information_jobs!]!

  """
  fetch aggregated fields from the table: "timescaledb_information.jobs"
  """
  timescaledb_information_jobs_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [timescaledb_information_jobs_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [timescaledb_information_jobs_order_by!]

    """
    filter the rows returned
    """
    where: timescaledb_information_jobs_bool_exp
  ): timescaledb_information_jobs_aggregate!

  """
  An array relationship
  """
  tokens(
    """
    distinct select on columns
    """
    distinct_on: [tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tokens_order_by!]

    """
    filter the rows returned
    """
    where: tokens_bool_exp
  ): [tokens!]!

  """
  An aggregate relationship
  """
  tokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tokens_order_by!]

    """
    filter the rows returned
    """
    where: tokens_bool_exp
  ): tokens_aggregate!

  """
  fetch data from the table: "tokens" using primary key columns
  """
  tokens_by_pk(developer_id: Int!, slug: String!): tokens

  """
  fetch data from the table: "usage"
  """
  usage(
    """
    distinct select on columns
    """
    distinct_on: [usage_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [usage_order_by!]

    """
    filter the rows returned
    """
    where: usage_bool_exp
  ): [usage!]!

  """
  fetch aggregated fields from the table: "usage"
  """
  usage_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [usage_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [usage_order_by!]

    """
    filter the rows returned
    """
    where: usage_bool_exp
  ): usage_aggregate!
}

"""
columns and relationships of "timescaledb_information.chunks"
"""
type timescaledb_information_chunks {
  chunk_name: name
  chunk_schema: name
  chunk_tablespace: name
  data_nodes: _name
  hypertable_name: name
  hypertable_schema: name
  is_compressed: Boolean
  primary_dimension: name
  primary_dimension_type: regtype
  range_end: timestamptz
  range_end_integer: bigint
  range_start: timestamptz
  range_start_integer: bigint
}

"""
aggregated selection of "timescaledb_information.chunks"
"""
type timescaledb_information_chunks_aggregate {
  aggregate: timescaledb_information_chunks_aggregate_fields
  nodes: [timescaledb_information_chunks!]!
}

"""
aggregate fields of "timescaledb_information.chunks"
"""
type timescaledb_information_chunks_aggregate_fields {
  avg: timescaledb_information_chunks_avg_fields
  count(
    columns: [timescaledb_information_chunks_select_column!]
    distinct: Boolean
  ): Int!
  max: timescaledb_information_chunks_max_fields
  min: timescaledb_information_chunks_min_fields
  stddev: timescaledb_information_chunks_stddev_fields
  stddev_pop: timescaledb_information_chunks_stddev_pop_fields
  stddev_samp: timescaledb_information_chunks_stddev_samp_fields
  sum: timescaledb_information_chunks_sum_fields
  var_pop: timescaledb_information_chunks_var_pop_fields
  var_samp: timescaledb_information_chunks_var_samp_fields
  variance: timescaledb_information_chunks_variance_fields
}

"""
aggregate avg on columns
"""
type timescaledb_information_chunks_avg_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
Boolean expression to filter rows from the table
"timescaledb_information.chunks". All fields are combined with a logical 'AND'.
"""
input timescaledb_information_chunks_bool_exp {
  _and: [timescaledb_information_chunks_bool_exp!]
  _not: timescaledb_information_chunks_bool_exp
  _or: [timescaledb_information_chunks_bool_exp!]
  chunk_name: name_comparison_exp
  chunk_schema: name_comparison_exp
  chunk_tablespace: name_comparison_exp
  data_nodes: _name_comparison_exp
  hypertable_name: name_comparison_exp
  hypertable_schema: name_comparison_exp
  is_compressed: Boolean_comparison_exp
  primary_dimension: name_comparison_exp
  primary_dimension_type: regtype_comparison_exp
  range_end: timestamptz_comparison_exp
  range_end_integer: bigint_comparison_exp
  range_start: timestamptz_comparison_exp
  range_start_integer: bigint_comparison_exp
}

"""
aggregate max on columns
"""
type timescaledb_information_chunks_max_fields {
  range_end: timestamptz
  range_end_integer: bigint
  range_start: timestamptz
  range_start_integer: bigint
}

"""
aggregate min on columns
"""
type timescaledb_information_chunks_min_fields {
  range_end: timestamptz
  range_end_integer: bigint
  range_start: timestamptz
  range_start_integer: bigint
}

"""
Ordering options when selecting data from "timescaledb_information.chunks".
"""
input timescaledb_information_chunks_order_by {
  chunk_name: order_by
  chunk_schema: order_by
  chunk_tablespace: order_by
  data_nodes: order_by
  hypertable_name: order_by
  hypertable_schema: order_by
  is_compressed: order_by
  primary_dimension: order_by
  primary_dimension_type: order_by
  range_end: order_by
  range_end_integer: order_by
  range_start: order_by
  range_start_integer: order_by
}

"""
select columns of table "timescaledb_information.chunks"
"""
enum timescaledb_information_chunks_select_column {
  """
  column name
  """
  chunk_name

  """
  column name
  """
  chunk_schema

  """
  column name
  """
  chunk_tablespace

  """
  column name
  """
  data_nodes

  """
  column name
  """
  hypertable_name

  """
  column name
  """
  hypertable_schema

  """
  column name
  """
  is_compressed

  """
  column name
  """
  primary_dimension

  """
  column name
  """
  primary_dimension_type

  """
  column name
  """
  range_end

  """
  column name
  """
  range_end_integer

  """
  column name
  """
  range_start

  """
  column name
  """
  range_start_integer
}

"""
aggregate stddev on columns
"""
type timescaledb_information_chunks_stddev_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
aggregate stddev_pop on columns
"""
type timescaledb_information_chunks_stddev_pop_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
aggregate stddev_samp on columns
"""
type timescaledb_information_chunks_stddev_samp_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
aggregate sum on columns
"""
type timescaledb_information_chunks_sum_fields {
  range_end_integer: bigint
  range_start_integer: bigint
}

"""
aggregate var_pop on columns
"""
type timescaledb_information_chunks_var_pop_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
aggregate var_samp on columns
"""
type timescaledb_information_chunks_var_samp_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
aggregate variance on columns
"""
type timescaledb_information_chunks_variance_fields {
  range_end_integer: Float
  range_start_integer: Float
}

"""
columns and relationships of "timescaledb_information.compression_settings"
"""
type timescaledb_information_compression_settings {
  attname: name
  hypertable_name: name
  hypertable_schema: name
  orderby_asc: Boolean
  orderby_column_index: smallint
  orderby_nullsfirst: Boolean
  segmentby_column_index: smallint
}

"""
aggregated selection of "timescaledb_information.compression_settings"
"""
type timescaledb_information_compression_settings_aggregate {
  aggregate: timescaledb_information_compression_settings_aggregate_fields
  nodes: [timescaledb_information_compression_settings!]!
}

"""
aggregate fields of "timescaledb_information.compression_settings"
"""
type timescaledb_information_compression_settings_aggregate_fields {
  avg: timescaledb_information_compression_settings_avg_fields
  count(
    columns: [timescaledb_information_compression_settings_select_column!]
    distinct: Boolean
  ): Int!
  max: timescaledb_information_compression_settings_max_fields
  min: timescaledb_information_compression_settings_min_fields
  stddev: timescaledb_information_compression_settings_stddev_fields
  stddev_pop: timescaledb_information_compression_settings_stddev_pop_fields
  stddev_samp: timescaledb_information_compression_settings_stddev_samp_fields
  sum: timescaledb_information_compression_settings_sum_fields
  var_pop: timescaledb_information_compression_settings_var_pop_fields
  var_samp: timescaledb_information_compression_settings_var_samp_fields
  variance: timescaledb_information_compression_settings_variance_fields
}

"""
aggregate avg on columns
"""
type timescaledb_information_compression_settings_avg_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
Boolean expression to filter rows from the table
"timescaledb_information.compression_settings". All fields are combined with a logical 'AND'.
"""
input timescaledb_information_compression_settings_bool_exp {
  _and: [timescaledb_information_compression_settings_bool_exp!]
  _not: timescaledb_information_compression_settings_bool_exp
  _or: [timescaledb_information_compression_settings_bool_exp!]
  attname: name_comparison_exp
  hypertable_name: name_comparison_exp
  hypertable_schema: name_comparison_exp
  orderby_asc: Boolean_comparison_exp
  orderby_column_index: smallint_comparison_exp
  orderby_nullsfirst: Boolean_comparison_exp
  segmentby_column_index: smallint_comparison_exp
}

"""
aggregate max on columns
"""
type timescaledb_information_compression_settings_max_fields {
  orderby_column_index: smallint
  segmentby_column_index: smallint
}

"""
aggregate min on columns
"""
type timescaledb_information_compression_settings_min_fields {
  orderby_column_index: smallint
  segmentby_column_index: smallint
}

"""
Ordering options when selecting data from "timescaledb_information.compression_settings".
"""
input timescaledb_information_compression_settings_order_by {
  attname: order_by
  hypertable_name: order_by
  hypertable_schema: order_by
  orderby_asc: order_by
  orderby_column_index: order_by
  orderby_nullsfirst: order_by
  segmentby_column_index: order_by
}

"""
select columns of table "timescaledb_information.compression_settings"
"""
enum timescaledb_information_compression_settings_select_column {
  """
  column name
  """
  attname

  """
  column name
  """
  hypertable_name

  """
  column name
  """
  hypertable_schema

  """
  column name
  """
  orderby_asc

  """
  column name
  """
  orderby_column_index

  """
  column name
  """
  orderby_nullsfirst

  """
  column name
  """
  segmentby_column_index
}

"""
aggregate stddev on columns
"""
type timescaledb_information_compression_settings_stddev_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
aggregate stddev_pop on columns
"""
type timescaledb_information_compression_settings_stddev_pop_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
aggregate stddev_samp on columns
"""
type timescaledb_information_compression_settings_stddev_samp_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
aggregate sum on columns
"""
type timescaledb_information_compression_settings_sum_fields {
  orderby_column_index: smallint
  segmentby_column_index: smallint
}

"""
aggregate var_pop on columns
"""
type timescaledb_information_compression_settings_var_pop_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
aggregate var_samp on columns
"""
type timescaledb_information_compression_settings_var_samp_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
aggregate variance on columns
"""
type timescaledb_information_compression_settings_variance_fields {
  orderby_column_index: Float
  segmentby_column_index: Float
}

"""
columns and relationships of "timescaledb_information.continuous_aggregates"
"""
type timescaledb_information_continuous_aggregates {
  hypertable_name: name
  hypertable_schema: name
  materialization_hypertable_name: name
  materialization_hypertable_schema: name
  materialized_only: Boolean
  view_definition: String
  view_name: name
  view_owner: name
  view_schema: name
}

"""
aggregated selection of "timescaledb_information.continuous_aggregates"
"""
type timescaledb_information_continuous_aggregates_aggregate {
  aggregate: timescaledb_information_continuous_aggregates_aggregate_fields
  nodes: [timescaledb_information_continuous_aggregates!]!
}

"""
aggregate fields of "timescaledb_information.continuous_aggregates"
"""
type timescaledb_information_continuous_aggregates_aggregate_fields {
  count(
    columns: [timescaledb_information_continuous_aggregates_select_column!]
    distinct: Boolean
  ): Int!
  max: timescaledb_information_continuous_aggregates_max_fields
  min: timescaledb_information_continuous_aggregates_min_fields
}

"""
Boolean expression to filter rows from the table
"timescaledb_information.continuous_aggregates". All fields are combined with a logical 'AND'.
"""
input timescaledb_information_continuous_aggregates_bool_exp {
  _and: [timescaledb_information_continuous_aggregates_bool_exp!]
  _not: timescaledb_information_continuous_aggregates_bool_exp
  _or: [timescaledb_information_continuous_aggregates_bool_exp!]
  hypertable_name: name_comparison_exp
  hypertable_schema: name_comparison_exp
  materialization_hypertable_name: name_comparison_exp
  materialization_hypertable_schema: name_comparison_exp
  materialized_only: Boolean_comparison_exp
  view_definition: String_comparison_exp
  view_name: name_comparison_exp
  view_owner: name_comparison_exp
  view_schema: name_comparison_exp
}

"""
aggregate max on columns
"""
type timescaledb_information_continuous_aggregates_max_fields {
  view_definition: String
}

"""
aggregate min on columns
"""
type timescaledb_information_continuous_aggregates_min_fields {
  view_definition: String
}

"""
Ordering options when selecting data from "timescaledb_information.continuous_aggregates".
"""
input timescaledb_information_continuous_aggregates_order_by {
  hypertable_name: order_by
  hypertable_schema: order_by
  materialization_hypertable_name: order_by
  materialization_hypertable_schema: order_by
  materialized_only: order_by
  view_definition: order_by
  view_name: order_by
  view_owner: order_by
  view_schema: order_by
}

"""
select columns of table "timescaledb_information.continuous_aggregates"
"""
enum timescaledb_information_continuous_aggregates_select_column {
  """
  column name
  """
  hypertable_name

  """
  column name
  """
  hypertable_schema

  """
  column name
  """
  materialization_hypertable_name

  """
  column name
  """
  materialization_hypertable_schema

  """
  column name
  """
  materialized_only

  """
  column name
  """
  view_definition

  """
  column name
  """
  view_name

  """
  column name
  """
  view_owner

  """
  column name
  """
  view_schema
}

"""
columns and relationships of "timescaledb_information.hypertables"
"""
type timescaledb_information_hypertables {
  compression_enabled: Boolean
  data_nodes: _name
  hypertable_name: name
  hypertable_schema: name
  is_distributed: Boolean
  num_chunks: bigint
  num_dimensions: smallint
  owner: name
  replication_factor: smallint
  tablespaces: _name
}

"""
aggregated selection of "timescaledb_information.hypertables"
"""
type timescaledb_information_hypertables_aggregate {
  aggregate: timescaledb_information_hypertables_aggregate_fields
  nodes: [timescaledb_information_hypertables!]!
}

"""
aggregate fields of "timescaledb_information.hypertables"
"""
type timescaledb_information_hypertables_aggregate_fields {
  avg: timescaledb_information_hypertables_avg_fields
  count(
    columns: [timescaledb_information_hypertables_select_column!]
    distinct: Boolean
  ): Int!
  max: timescaledb_information_hypertables_max_fields
  min: timescaledb_information_hypertables_min_fields
  stddev: timescaledb_information_hypertables_stddev_fields
  stddev_pop: timescaledb_information_hypertables_stddev_pop_fields
  stddev_samp: timescaledb_information_hypertables_stddev_samp_fields
  sum: timescaledb_information_hypertables_sum_fields
  var_pop: timescaledb_information_hypertables_var_pop_fields
  var_samp: timescaledb_information_hypertables_var_samp_fields
  variance: timescaledb_information_hypertables_variance_fields
}

"""
aggregate avg on columns
"""
type timescaledb_information_hypertables_avg_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
Boolean expression to filter rows from the table
"timescaledb_information.hypertables". All fields are combined with a logical 'AND'.
"""
input timescaledb_information_hypertables_bool_exp {
  _and: [timescaledb_information_hypertables_bool_exp!]
  _not: timescaledb_information_hypertables_bool_exp
  _or: [timescaledb_information_hypertables_bool_exp!]
  compression_enabled: Boolean_comparison_exp
  data_nodes: _name_comparison_exp
  hypertable_name: name_comparison_exp
  hypertable_schema: name_comparison_exp
  is_distributed: Boolean_comparison_exp
  num_chunks: bigint_comparison_exp
  num_dimensions: smallint_comparison_exp
  owner: name_comparison_exp
  replication_factor: smallint_comparison_exp
  tablespaces: _name_comparison_exp
}

"""
aggregate max on columns
"""
type timescaledb_information_hypertables_max_fields {
  num_chunks: bigint
  num_dimensions: smallint
  replication_factor: smallint
}

"""
aggregate min on columns
"""
type timescaledb_information_hypertables_min_fields {
  num_chunks: bigint
  num_dimensions: smallint
  replication_factor: smallint
}

"""
Ordering options when selecting data from "timescaledb_information.hypertables".
"""
input timescaledb_information_hypertables_order_by {
  compression_enabled: order_by
  data_nodes: order_by
  hypertable_name: order_by
  hypertable_schema: order_by
  is_distributed: order_by
  num_chunks: order_by
  num_dimensions: order_by
  owner: order_by
  replication_factor: order_by
  tablespaces: order_by
}

"""
select columns of table "timescaledb_information.hypertables"
"""
enum timescaledb_information_hypertables_select_column {
  """
  column name
  """
  compression_enabled

  """
  column name
  """
  data_nodes

  """
  column name
  """
  hypertable_name

  """
  column name
  """
  hypertable_schema

  """
  column name
  """
  is_distributed

  """
  column name
  """
  num_chunks

  """
  column name
  """
  num_dimensions

  """
  column name
  """
  owner

  """
  column name
  """
  replication_factor

  """
  column name
  """
  tablespaces
}

"""
aggregate stddev on columns
"""
type timescaledb_information_hypertables_stddev_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
aggregate stddev_pop on columns
"""
type timescaledb_information_hypertables_stddev_pop_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
aggregate stddev_samp on columns
"""
type timescaledb_information_hypertables_stddev_samp_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
aggregate sum on columns
"""
type timescaledb_information_hypertables_sum_fields {
  num_chunks: bigint
  num_dimensions: smallint
  replication_factor: smallint
}

"""
aggregate var_pop on columns
"""
type timescaledb_information_hypertables_var_pop_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
aggregate var_samp on columns
"""
type timescaledb_information_hypertables_var_samp_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
aggregate variance on columns
"""
type timescaledb_information_hypertables_variance_fields {
  num_chunks: Float
  num_dimensions: Float
  replication_factor: Float
}

"""
columns and relationships of "timescaledb_information.job_stats"
"""
type timescaledb_information_job_stats {
  hypertable_name: name
  hypertable_schema: name
  job_id: Int
  job_status: String
  last_run_duration: interval
  last_run_started_at: timestamptz
  last_run_status: String
  last_successful_finish: timestamptz
  next_start: timestamptz
  total_failures: bigint
  total_runs: bigint
  total_successes: bigint
}

"""
aggregated selection of "timescaledb_information.job_stats"
"""
type timescaledb_information_job_stats_aggregate {
  aggregate: timescaledb_information_job_stats_aggregate_fields
  nodes: [timescaledb_information_job_stats!]!
}

"""
aggregate fields of "timescaledb_information.job_stats"
"""
type timescaledb_information_job_stats_aggregate_fields {
  avg: timescaledb_information_job_stats_avg_fields
  count(
    columns: [timescaledb_information_job_stats_select_column!]
    distinct: Boolean
  ): Int!
  max: timescaledb_information_job_stats_max_fields
  min: timescaledb_information_job_stats_min_fields
  stddev: timescaledb_information_job_stats_stddev_fields
  stddev_pop: timescaledb_information_job_stats_stddev_pop_fields
  stddev_samp: timescaledb_information_job_stats_stddev_samp_fields
  sum: timescaledb_information_job_stats_sum_fields
  var_pop: timescaledb_information_job_stats_var_pop_fields
  var_samp: timescaledb_information_job_stats_var_samp_fields
  variance: timescaledb_information_job_stats_variance_fields
}

"""
aggregate avg on columns
"""
type timescaledb_information_job_stats_avg_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
Boolean expression to filter rows from the table
"timescaledb_information.job_stats". All fields are combined with a logical 'AND'.
"""
input timescaledb_information_job_stats_bool_exp {
  _and: [timescaledb_information_job_stats_bool_exp!]
  _not: timescaledb_information_job_stats_bool_exp
  _or: [timescaledb_information_job_stats_bool_exp!]
  hypertable_name: name_comparison_exp
  hypertable_schema: name_comparison_exp
  job_id: Int_comparison_exp
  job_status: String_comparison_exp
  last_run_duration: interval_comparison_exp
  last_run_started_at: timestamptz_comparison_exp
  last_run_status: String_comparison_exp
  last_successful_finish: timestamptz_comparison_exp
  next_start: timestamptz_comparison_exp
  total_failures: bigint_comparison_exp
  total_runs: bigint_comparison_exp
  total_successes: bigint_comparison_exp
}

"""
aggregate max on columns
"""
type timescaledb_information_job_stats_max_fields {
  job_id: Int
  job_status: String
  last_run_started_at: timestamptz
  last_run_status: String
  last_successful_finish: timestamptz
  next_start: timestamptz
  total_failures: bigint
  total_runs: bigint
  total_successes: bigint
}

"""
aggregate min on columns
"""
type timescaledb_information_job_stats_min_fields {
  job_id: Int
  job_status: String
  last_run_started_at: timestamptz
  last_run_status: String
  last_successful_finish: timestamptz
  next_start: timestamptz
  total_failures: bigint
  total_runs: bigint
  total_successes: bigint
}

"""
Ordering options when selecting data from "timescaledb_information.job_stats".
"""
input timescaledb_information_job_stats_order_by {
  hypertable_name: order_by
  hypertable_schema: order_by
  job_id: order_by
  job_status: order_by
  last_run_duration: order_by
  last_run_started_at: order_by
  last_run_status: order_by
  last_successful_finish: order_by
  next_start: order_by
  total_failures: order_by
  total_runs: order_by
  total_successes: order_by
}

"""
select columns of table "timescaledb_information.job_stats"
"""
enum timescaledb_information_job_stats_select_column {
  """
  column name
  """
  hypertable_name

  """
  column name
  """
  hypertable_schema

  """
  column name
  """
  job_id

  """
  column name
  """
  job_status

  """
  column name
  """
  last_run_duration

  """
  column name
  """
  last_run_started_at

  """
  column name
  """
  last_run_status

  """
  column name
  """
  last_successful_finish

  """
  column name
  """
  next_start

  """
  column name
  """
  total_failures

  """
  column name
  """
  total_runs

  """
  column name
  """
  total_successes
}

"""
aggregate stddev on columns
"""
type timescaledb_information_job_stats_stddev_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
aggregate stddev_pop on columns
"""
type timescaledb_information_job_stats_stddev_pop_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
aggregate stddev_samp on columns
"""
type timescaledb_information_job_stats_stddev_samp_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
aggregate sum on columns
"""
type timescaledb_information_job_stats_sum_fields {
  job_id: Int
  total_failures: bigint
  total_runs: bigint
  total_successes: bigint
}

"""
aggregate var_pop on columns
"""
type timescaledb_information_job_stats_var_pop_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
aggregate var_samp on columns
"""
type timescaledb_information_job_stats_var_samp_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
aggregate variance on columns
"""
type timescaledb_information_job_stats_variance_fields {
  job_id: Float
  total_failures: Float
  total_runs: Float
  total_successes: Float
}

"""
columns and relationships of "timescaledb_information.jobs"
"""
type timescaledb_information_jobs {
  application_name: name
  config(
    """
    JSON select path
    """
    path: String
  ): jsonb
  hypertable_name: name
  hypertable_schema: name
  job_id: Int
  max_retries: Int
  max_runtime: interval
  next_start: timestamptz
  owner: name
  proc_name: name
  proc_schema: name
  retry_period: interval
  schedule_interval: interval
  scheduled: Boolean
}

"""
aggregated selection of "timescaledb_information.jobs"
"""
type timescaledb_information_jobs_aggregate {
  aggregate: timescaledb_information_jobs_aggregate_fields
  nodes: [timescaledb_information_jobs!]!
}

"""
aggregate fields of "timescaledb_information.jobs"
"""
type timescaledb_information_jobs_aggregate_fields {
  avg: timescaledb_information_jobs_avg_fields
  count(
    columns: [timescaledb_information_jobs_select_column!]
    distinct: Boolean
  ): Int!
  max: timescaledb_information_jobs_max_fields
  min: timescaledb_information_jobs_min_fields
  stddev: timescaledb_information_jobs_stddev_fields
  stddev_pop: timescaledb_information_jobs_stddev_pop_fields
  stddev_samp: timescaledb_information_jobs_stddev_samp_fields
  sum: timescaledb_information_jobs_sum_fields
  var_pop: timescaledb_information_jobs_var_pop_fields
  var_samp: timescaledb_information_jobs_var_samp_fields
  variance: timescaledb_information_jobs_variance_fields
}

"""
aggregate avg on columns
"""
type timescaledb_information_jobs_avg_fields {
  job_id: Float
  max_retries: Float
}

"""
Boolean expression to filter rows from the table "timescaledb_information.jobs".
All fields are combined with a logical 'AND'.
"""
input timescaledb_information_jobs_bool_exp {
  _and: [timescaledb_information_jobs_bool_exp!]
  _not: timescaledb_information_jobs_bool_exp
  _or: [timescaledb_information_jobs_bool_exp!]
  application_name: name_comparison_exp
  config: jsonb_comparison_exp
  hypertable_name: name_comparison_exp
  hypertable_schema: name_comparison_exp
  job_id: Int_comparison_exp
  max_retries: Int_comparison_exp
  max_runtime: interval_comparison_exp
  next_start: timestamptz_comparison_exp
  owner: name_comparison_exp
  proc_name: name_comparison_exp
  proc_schema: name_comparison_exp
  retry_period: interval_comparison_exp
  schedule_interval: interval_comparison_exp
  scheduled: Boolean_comparison_exp
}

"""
aggregate max on columns
"""
type timescaledb_information_jobs_max_fields {
  job_id: Int
  max_retries: Int
  next_start: timestamptz
}

"""
aggregate min on columns
"""
type timescaledb_information_jobs_min_fields {
  job_id: Int
  max_retries: Int
  next_start: timestamptz
}

"""
Ordering options when selecting data from "timescaledb_information.jobs".
"""
input timescaledb_information_jobs_order_by {
  application_name: order_by
  config: order_by
  hypertable_name: order_by
  hypertable_schema: order_by
  job_id: order_by
  max_retries: order_by
  max_runtime: order_by
  next_start: order_by
  owner: order_by
  proc_name: order_by
  proc_schema: order_by
  retry_period: order_by
  schedule_interval: order_by
  scheduled: order_by
}

"""
select columns of table "timescaledb_information.jobs"
"""
enum timescaledb_information_jobs_select_column {
  """
  column name
  """
  application_name

  """
  column name
  """
  config

  """
  column name
  """
  hypertable_name

  """
  column name
  """
  hypertable_schema

  """
  column name
  """
  job_id

  """
  column name
  """
  max_retries

  """
  column name
  """
  max_runtime

  """
  column name
  """
  next_start

  """
  column name
  """
  owner

  """
  column name
  """
  proc_name

  """
  column name
  """
  proc_schema

  """
  column name
  """
  retry_period

  """
  column name
  """
  schedule_interval

  """
  column name
  """
  scheduled
}

"""
aggregate stddev on columns
"""
type timescaledb_information_jobs_stddev_fields {
  job_id: Float
  max_retries: Float
}

"""
aggregate stddev_pop on columns
"""
type timescaledb_information_jobs_stddev_pop_fields {
  job_id: Float
  max_retries: Float
}

"""
aggregate stddev_samp on columns
"""
type timescaledb_information_jobs_stddev_samp_fields {
  job_id: Float
  max_retries: Float
}

"""
aggregate sum on columns
"""
type timescaledb_information_jobs_sum_fields {
  job_id: Int
  max_retries: Int
}

"""
aggregate var_pop on columns
"""
type timescaledb_information_jobs_var_pop_fields {
  job_id: Float
  max_retries: Float
}

"""
aggregate var_samp on columns
"""
type timescaledb_information_jobs_var_samp_fields {
  job_id: Float
  max_retries: Float
}

"""
aggregate variance on columns
"""
type timescaledb_information_jobs_variance_fields {
  job_id: Float
  max_retries: Float
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "tokens"
"""
type tokens {
  description: String!

  """
  An object relationship
  """
  developer: developers!
  developer_id: Int!
  slug: String!
  timestamp: timestamptz!
}

"""
aggregated selection of "tokens"
"""
type tokens_aggregate {
  aggregate: tokens_aggregate_fields
  nodes: [tokens!]!
}

"""
aggregate fields of "tokens"
"""
type tokens_aggregate_fields {
  avg: tokens_avg_fields
  count(columns: [tokens_select_column!], distinct: Boolean): Int!
  max: tokens_max_fields
  min: tokens_min_fields
  stddev: tokens_stddev_fields
  stddev_pop: tokens_stddev_pop_fields
  stddev_samp: tokens_stddev_samp_fields
  sum: tokens_sum_fields
  var_pop: tokens_var_pop_fields
  var_samp: tokens_var_samp_fields
  variance: tokens_variance_fields
}

"""
order by aggregate values of table "tokens"
"""
input tokens_aggregate_order_by {
  avg: tokens_avg_order_by
  count: order_by
  max: tokens_max_order_by
  min: tokens_min_order_by
  stddev: tokens_stddev_order_by
  stddev_pop: tokens_stddev_pop_order_by
  stddev_samp: tokens_stddev_samp_order_by
  sum: tokens_sum_order_by
  var_pop: tokens_var_pop_order_by
  var_samp: tokens_var_samp_order_by
  variance: tokens_variance_order_by
}

"""
input type for inserting array relation for remote table "tokens"
"""
input tokens_arr_rel_insert_input {
  data: [tokens_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tokens_on_conflict
}

"""
aggregate avg on columns
"""
type tokens_avg_fields {
  developer_id: Float
}

"""
order by avg() on columns of table "tokens"
"""
input tokens_avg_order_by {
  developer_id: order_by
}

"""
Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'.
"""
input tokens_bool_exp {
  _and: [tokens_bool_exp!]
  _not: tokens_bool_exp
  _or: [tokens_bool_exp!]
  description: String_comparison_exp
  developer: developers_bool_exp
  developer_id: Int_comparison_exp
  slug: String_comparison_exp
  timestamp: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "tokens"
"""
enum tokens_constraint {
  """
  unique or primary key constraint
  """
  tokens_pkey
}

"""
input type for incrementing numeric columns in table "tokens"
"""
input tokens_inc_input {
  developer_id: Int
}

"""
input type for inserting data into table "tokens"
"""
input tokens_insert_input {
  description: String
  developer: developers_obj_rel_insert_input
  developer_id: Int
  slug: String
  timestamp: timestamptz
}

"""
aggregate max on columns
"""
type tokens_max_fields {
  description: String
  developer_id: Int
  slug: String
  timestamp: timestamptz
}

"""
order by max() on columns of table "tokens"
"""
input tokens_max_order_by {
  description: order_by
  developer_id: order_by
  slug: order_by
  timestamp: order_by
}

"""
aggregate min on columns
"""
type tokens_min_fields {
  description: String
  developer_id: Int
  slug: String
  timestamp: timestamptz
}

"""
order by min() on columns of table "tokens"
"""
input tokens_min_order_by {
  description: order_by
  developer_id: order_by
  slug: order_by
  timestamp: order_by
}

"""
response of any mutation on the table "tokens"
"""
type tokens_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tokens!]!
}

"""
on conflict condition type for table "tokens"
"""
input tokens_on_conflict {
  constraint: tokens_constraint!
  update_columns: [tokens_update_column!]! = []
  where: tokens_bool_exp
}

"""
Ordering options when selecting data from "tokens".
"""
input tokens_order_by {
  description: order_by
  developer: developers_order_by
  developer_id: order_by
  slug: order_by
  timestamp: order_by
}

"""
primary key columns input for table: tokens
"""
input tokens_pk_columns_input {
  developer_id: Int!
  slug: String!
}

"""
select columns of table "tokens"
"""
enum tokens_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  developer_id

  """
  column name
  """
  slug

  """
  column name
  """
  timestamp
}

"""
input type for updating data in table "tokens"
"""
input tokens_set_input {
  description: String
  developer_id: Int
  slug: String
  timestamp: timestamptz
}

"""
aggregate stddev on columns
"""
type tokens_stddev_fields {
  developer_id: Float
}

"""
order by stddev() on columns of table "tokens"
"""
input tokens_stddev_order_by {
  developer_id: order_by
}

"""
aggregate stddev_pop on columns
"""
type tokens_stddev_pop_fields {
  developer_id: Float
}

"""
order by stddev_pop() on columns of table "tokens"
"""
input tokens_stddev_pop_order_by {
  developer_id: order_by
}

"""
aggregate stddev_samp on columns
"""
type tokens_stddev_samp_fields {
  developer_id: Float
}

"""
order by stddev_samp() on columns of table "tokens"
"""
input tokens_stddev_samp_order_by {
  developer_id: order_by
}

"""
aggregate sum on columns
"""
type tokens_sum_fields {
  developer_id: Int
}

"""
order by sum() on columns of table "tokens"
"""
input tokens_sum_order_by {
  developer_id: order_by
}

"""
update columns of table "tokens"
"""
enum tokens_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  developer_id

  """
  column name
  """
  slug

  """
  column name
  """
  timestamp
}

"""
aggregate var_pop on columns
"""
type tokens_var_pop_fields {
  developer_id: Float
}

"""
order by var_pop() on columns of table "tokens"
"""
input tokens_var_pop_order_by {
  developer_id: order_by
}

"""
aggregate var_samp on columns
"""
type tokens_var_samp_fields {
  developer_id: Float
}

"""
order by var_samp() on columns of table "tokens"
"""
input tokens_var_samp_order_by {
  developer_id: order_by
}

"""
aggregate variance on columns
"""
type tokens_variance_fields {
  developer_id: Float
}

"""
order by variance() on columns of table "tokens"
"""
input tokens_variance_order_by {
  developer_id: order_by
}

"""
Topic scores
"""
type TopicScore {
  score: Float!
  topic: String!
}

"""
Topic classification results
"""
type TopicsResult {
  result: [TopicScore!]!
}

"""
Output result
"""
type TranscribeResult {
  """
  Transcription
  """
  result: String!
}

input Turn {
  bot: String = null
  user: String = null
}

"""
columns and relationships of "usage"
"""
type usage {
  """
  An object relationship
  """
  developer: developers!
  developer_id: Int!
  execution_time: Int!
  payload_hash: String!
  service_name: String
  success: Boolean!
  timestamp: timestamptz!
}

"""
aggregated selection of "usage"
"""
type usage_aggregate {
  aggregate: usage_aggregate_fields
  nodes: [usage!]!
}

"""
aggregate fields of "usage"
"""
type usage_aggregate_fields {
  avg: usage_avg_fields
  count(columns: [usage_select_column!], distinct: Boolean): Int!
  max: usage_max_fields
  min: usage_min_fields
  stddev: usage_stddev_fields
  stddev_pop: usage_stddev_pop_fields
  stddev_samp: usage_stddev_samp_fields
  sum: usage_sum_fields
  var_pop: usage_var_pop_fields
  var_samp: usage_var_samp_fields
  variance: usage_variance_fields
}

"""
order by aggregate values of table "usage"
"""
input usage_aggregate_order_by {
  avg: usage_avg_order_by
  count: order_by
  max: usage_max_order_by
  min: usage_min_order_by
  stddev: usage_stddev_order_by
  stddev_pop: usage_stddev_pop_order_by
  stddev_samp: usage_stddev_samp_order_by
  sum: usage_sum_order_by
  var_pop: usage_var_pop_order_by
  var_samp: usage_var_samp_order_by
  variance: usage_variance_order_by
}

"""
input type for inserting array relation for remote table "usage"
"""
input usage_arr_rel_insert_input {
  data: [usage_insert_input!]!
}

"""
aggregate avg on columns
"""
type usage_avg_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by avg() on columns of table "usage"
"""
input usage_avg_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
Boolean expression to filter rows from the table "usage". All fields are combined with a logical 'AND'.
"""
input usage_bool_exp {
  _and: [usage_bool_exp!]
  _not: usage_bool_exp
  _or: [usage_bool_exp!]
  developer: developers_bool_exp
  developer_id: Int_comparison_exp
  execution_time: Int_comparison_exp
  payload_hash: String_comparison_exp
  service_name: String_comparison_exp
  success: Boolean_comparison_exp
  timestamp: timestamptz_comparison_exp
}

"""
input type for incrementing numeric columns in table "usage"
"""
input usage_inc_input {
  developer_id: Int
  execution_time: Int
}

"""
input type for inserting data into table "usage"
"""
input usage_insert_input {
  developer: developers_obj_rel_insert_input
  developer_id: Int
  execution_time: Int
  payload_hash: String
  service_name: String
  success: Boolean
  timestamp: timestamptz
}

"""
aggregate max on columns
"""
type usage_max_fields {
  developer_id: Int
  execution_time: Int
  payload_hash: String
  service_name: String
  timestamp: timestamptz
}

"""
order by max() on columns of table "usage"
"""
input usage_max_order_by {
  developer_id: order_by
  execution_time: order_by
  payload_hash: order_by
  service_name: order_by
  timestamp: order_by
}

"""
aggregate min on columns
"""
type usage_min_fields {
  developer_id: Int
  execution_time: Int
  payload_hash: String
  service_name: String
  timestamp: timestamptz
}

"""
order by min() on columns of table "usage"
"""
input usage_min_order_by {
  developer_id: order_by
  execution_time: order_by
  payload_hash: order_by
  service_name: order_by
  timestamp: order_by
}

"""
response of any mutation on the table "usage"
"""
type usage_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [usage!]!
}

"""
Ordering options when selecting data from "usage".
"""
input usage_order_by {
  developer: developers_order_by
  developer_id: order_by
  execution_time: order_by
  payload_hash: order_by
  service_name: order_by
  success: order_by
  timestamp: order_by
}

"""
select columns of table "usage"
"""
enum usage_select_column {
  """
  column name
  """
  developer_id

  """
  column name
  """
  execution_time

  """
  column name
  """
  payload_hash

  """
  column name
  """
  service_name

  """
  column name
  """
  success

  """
  column name
  """
  timestamp
}

"""
input type for updating data in table "usage"
"""
input usage_set_input {
  developer_id: Int
  execution_time: Int
  payload_hash: String
  service_name: String
  success: Boolean
  timestamp: timestamptz
}

"""
aggregate stddev on columns
"""
type usage_stddev_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by stddev() on columns of table "usage"
"""
input usage_stddev_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
aggregate stddev_pop on columns
"""
type usage_stddev_pop_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by stddev_pop() on columns of table "usage"
"""
input usage_stddev_pop_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
aggregate stddev_samp on columns
"""
type usage_stddev_samp_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by stddev_samp() on columns of table "usage"
"""
input usage_stddev_samp_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
aggregate sum on columns
"""
type usage_sum_fields {
  developer_id: Int
  execution_time: Int
}

"""
order by sum() on columns of table "usage"
"""
input usage_sum_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
aggregate var_pop on columns
"""
type usage_var_pop_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by var_pop() on columns of table "usage"
"""
input usage_var_pop_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
aggregate var_samp on columns
"""
type usage_var_samp_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by var_samp() on columns of table "usage"
"""
input usage_var_samp_order_by {
  developer_id: order_by
  execution_time: order_by
}

"""
aggregate variance on columns
"""
type usage_variance_fields {
  developer_id: Float
  execution_time: Float
}

"""
order by variance() on columns of table "usage"
"""
input usage_variance_order_by {
  developer_id: order_by
  execution_time: order_by
}
